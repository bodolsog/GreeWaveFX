<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        html { height: 100% }
        body { height: 100%; margin: 0px; padding: 0px }
        #map_canvas { height: 100%; background-color: #666970; }
        .context-menu {
            display: none;
            position: absolute;
            z-index: 10;
            padding: 0;
            width: 180px;
            background-color: #f8f8f8;
            border: solid 1px #b4b4b4;
            box-shadow: 1px 1px 2px #cfcfcf;
            font-size: 12px;
        }
        .context-menu--active {
            display: block;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }

        .context-menu__item{
            padding: 5px;
            text-decoration: none;
        }
        .context-menu__items{
            margin: 0;
        }
        .context-menu__link{
            text-decoration: none;
        }
        .menuItemHover {
            background: darkred;
        }
    </style>
    <script type="text/javascript">
        /* Add to head script file from Google API with Google API key from config. */
        var head = document.getElementsByTagName('head')[0];
        var key = properties.getGoogleAPIKey();

        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = 'http://maps.google.com/maps/api/js?key=' + key + '&sensor=false';
        head.appendChild(script);
    </script>
    <script type="text/javascript">
        function test(tex){
            document.getElementById('test').innerHTML = tex;
        }

        var activeMenu;

        /**
         * Context menu object.
         */
        var ContextMenu = function(marker, overlay){
            var marker = marker;

            /* Generate menu. */
            var menu = document.createElement('nav')
            menu.classList.add('context-menu');
            var ul = document.createElement('ul');
            ul.classList.add('context-menu__items');
            menu.appendChild(ul);
            document.querySelector('#menus').appendChild(menu);

            var menuGenerated = false;

            var options = {
                c1w: 'Connect 1 way',
                c2w: 'Commect 2 way',
                ct:  'Set cross type',
                del: 'Delete marker'
            };

            return {
                overlay: overlay,
                visibleCSSClass: 'context-menu--active',
                menuItemCSSClass: 'context-menu__item',
                isActive: function () {
                    return menu.classList.contains(this.visibleCSSClass);
                },
                open: function () {
                    if(activeMenu != null)
                        if(activeMenu.isActive())
                            activeMenu.close();
                    this.calculateMenuPosition();
                    if(!menuGenerated)
                        this.generateMenu();
                    menu.classList.add(this.visibleCSSClass); // show menu
                    activeMenu = this;
                },
                close: function () {
                    menu.classList.remove(this.visibleCSSClass);
                },
                toggle: function () {
                    if (this.isActive())
                        this.close();
                    else
                        this.open();
                },
                calculateMenuPosition: function () {
                    var point = this.overlay.getProjection().fromLatLngToContainerPixel(marker.getPosition())
                    menu.style.left = point.x + "px";
                    menu.style.top = point.y + "px";
                },
                generateMenu: function(){
                    for(key in options){
                        if(options[key] != null)
                            this.generateOption(key, options[key]);
                    menuGenerated = true;
                    }
                },
                generateOption: function(key, text){
                    var li = document.createElement('li');
                    li.classList.add(this.menuItemCSSClass);
                    li.innerHTML = text;
                    li.addEventListener('click', function(){
                        if(key == 'del'){
                            var x = confirm("sure?");
                            x = true;
                            if(x)
                                deleteMarker(marker);
                        }
                    });
                    li.addEventListener('mouseover', function(){
                        this.style.cursor="pointer";
                        this.classList.add('menuItemHover');
                    });
                    li.addEventListener('mouseout', function(){
                        this.classList.remove('menuItemHover');
                    });

                    ul.appendChild(li);
                },
                removeMenu: function(){
                    menu.remove();
                }
            };
        };

        /* Initialize Map */
        function initialize() {
            var counter = 0;
            /* Domestic center on Biala Podlaska. */
            var latlng = new google.maps.LatLng(52.03, 23.14);

            var map = new google.maps.Map(document.getElementById("map_canvas"), {
                zoom: 15,
                center: latlng,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                mapTypeControl: false,
                navigationControl: false,
                streetViewControl: false,
                backgroundColor: "#666970",
                zoomControl: false,
                scaleControl: true
            });

            /* Services */
            var directionsService = new google.maps.DirectionsService;

            var overlay = new google.maps.OverlayView();
            overlay.draw = function () {};
            overlay.setMap(map);

//            var directionsDisplay = new google.maps.DirectionsRenderer;
//            directionsDisplay.setMap(map);
//            geocoder = new google.maps.Geocoder();
//            service = new google.maps.DistanceMatrixService;
//            directionsService = new google.maps.DirectionsService;
//

//            var menuItem = menu.querySelectorAll(".context-menu__item")
//            for(i=0; i<menuItem.length; i++){
//                menuItem[i].addEventListener('click', function(){
//                    action = ;
//                    if(action == "connect2w" || action == "connect1w"){
//                        controller.connectMarkers(action, activeMarkerId, menuMarkerId);
//                        pointA = markersMap[activeMarkerId].getPosition();
//                        pointB = markersMap[menuMarkerId].getPosition();
//
//                        document.service.getDistanceMatrix({
//                            origins: [pointA],
//                            destinations: [pointB],
//                            travelMode: google.maps.TravelMode.DRIVING,
//                            unitSystem: google.maps.UnitSystem.METRIC,
//                            avoidHighways: true,
//                            avoidTolls: true
//                        }, function(response, status){
//                            if (status !== google.maps.DistanceMatrixStatus.OK) {
//                                test('Error was: ' + status);
//                            } else {
//                                test(response.rows[0].elements[0].distance.value);
//                            }
//                        });
//
//                        document.directionsService.route({
//                            origin: pointA,
//                            destination: pointB,
//                            travelMode: google.maps.TravelMode.DRIVING
//                        }, function(response, status) {
//                            if (status === google.maps.DirectionsStatus.OK) {
//                                document.directionsDisplay.setDirections(response);
//                            } else {
//                                test('Directions request failed due to ' + status);
//                            }
//                        });
//                    }
//                });
//            }


            map.addListener('mousedown', function(){
                if(activeMenu != null)
                    if(activeMenu.isActive())
                        activeMenu.close();
                    else
                        activeMenu = null;
            });

            map.addListener('click', function (event) {

                if(activeMenu == null) {
                    // Create marker
                    var marker = new google.maps.Marker({
                        position: event.latLng,
                        draggable: true,
                        map: map
                    });

                    toggleMarkersIcons(marker);
                    calibrateMarkerPosition(directionsService, marker);

                    // Add marker to lists.
                    controller.addMarker(marker);

                    // Create infowindow
                    marker.infowindow = new google.maps.InfoWindow({
                        content: infowindowContent(marker)
                    });

                    // Create context menu
                    marker.contextMenu = new ContextMenu(marker, overlay);

                    /* Marker listeners */
                    marker.addListener('click', function() {

                        if(activeMenu == null){
                            controller.log('null');
                            if(!isMarkerActive(marker))
                                setMarkerActive(marker);
                            else
                                marker.infowindow.open(map, marker);
                        }
                        else{
                            if(activeMenu.isActive()){
                                activeMenu.close();
                                activeMenu = null;
                            }
                        }
                    });

                    marker.addListener('drag', function () {
                        activeMenu.close();
                    });
                    marker.addListener('dragend', function () {
                        calibrateMarkerPosition(directionsService, this);
                    });

                    marker.addListener('rightclick', function () {
                        this.contextMenu.toggle();
                    });
                    /* End listeners */
                }
            });
        }


        /**
         * Return true if Marker is active.
         * @param marker
         */
        function isMarkerActive(marker){
            if(marker.id == controller.getMarkerActiveId())
                return true;
            return false;
        }

        /**
         * Set marker active and toggle old and new marker icon.
         * @param marker
         */
        function setMarkerActive(marker){
            toggleMarkersIcons(marker);
            controller.setMarkerActiveId(marker.id);
        }

        /**
         * Set active icon for newMarker and get from variable id of oldMarker. If this exists set domestic unactive
         * icon for him.
         * @param newMarker
         */
        function toggleMarkersIcons(newMarker){
            var oldMarker = controller.getMarkerActive();
            if(oldMarker != null)
                setMarkerIconUnactive(oldMarker);
            setMarkerIconActive(newMarker);
        }

        /**
         * Set domestic active icon for Marker.
         * @param marker
         */
        function setMarkerIconActive(marker){
            setMarkerIcon(marker, 'yellow', 'dot');
        }

        /**
         * Set domestic unactive icon for Marker.
         * @param marker
         */
        function setMarkerIconUnactive(marker){
            setMarkerIcon(marker, 'red', 'dot');
        }

        /**
         * Set marker icon.
         * @param marker
         * @param color String
         * @param emblem String
         */
        function setMarkerIcon(marker, color, emblem){
            if(emblem != null)
                emblem = '-'+emblem;
            else
                emblem = '';

            marker.setIcon('markers/'+color+emblem+'.png');
        }

        /**
         * Create infowidow content.
         * @param marker
         * @returns {string}
         */
        function infowindowContent(marker){
            return  "<div class='infowindow-content'>" +
                    "   <dl>" +
                    "       <dt>Coordinates:</dt>" +
                    "       <dd>Lat:"+ marker.getPosition().lat() +", Lng: "+ marker.getPosition().lng() +"</dd>" +
                    "       <dt>Type:</dt>" +
                    "       <dd>-</dd>" +
                    "   </dl>" +
                    "</div>";
        }

        /**
         * Removes and destroys marker.
         * @param marker
         */
        function deleteMarker(marker){
            activeMenu.close();
            if(controller.deleteMarker(marker.id)){
                marker.contextMenu.removeMenu();    // Remove menu from DOM
                marker.setMap(null);                // Remove Marker from Overlay
                marker = null;                      // Remove reference to Marker
            }
        }

        /**
         * Calculate center point of crossroads.
         * 
         * @param directionsService
         * @param marker
         */
        function calibrateMarkerPosition(directionsService, marker) {
            var lat = marker.getPosition().lat();
            var lng = marker.getPosition().lng();
            var dimension = 0.0003;

            var north = {lat: (lat+dimension), lng: lng};
            var south = {lat: (lat-dimension), lng: lng};
            var east = {lat: lat, lng: (lng+dimension)};
            var west = {lat: lat, lng: (lng-dimension)};

            // Calculate middle point for nort-east (this should work for all 4-way crossroads and for 3-way corossroads
            // with routes on north and east).
            directionsService.route(
                directionsServiceOptions(north, east), function (response, status){
                    if (status === google.maps.DirectionsStatus.OK){
                        var way = response.routes[0].legs[0];
                        // Calculate if result contains crossroads middle point, if yes - end function (return).
                        if(getCalibration(way, marker, lat, lng, dimension))
                            return;
                    }
                    // When first search not found middle point (status not OK or crossroads is 3-way without both north
                    // and east route. Then search for south-west.
                    directionsService.route(
                        directionsServiceOptions(south, west), function (response, status){
                            if (status === google.maps.DirectionsStatus.OK){
                                var way = response.routes[0].legs[0];
                                // Calculate if result contains crossroads middle point, if yes - end function (return).
                                if(getCalibration(way, marker, lat, lng, dimension))
                                    return;
                            }
                });
            });
            // When nothing found - marker stay there, where user has clicked (point is too far away from middle point
            // or it isn't near crossroad.
        }

        /**
         * Return options for directionService.
         * 
         * @param origin
         * @param destination
         * @returns {{origin: *, destination: *, travelMode: *}}
         */
        function directionsServiceOptions(origin, destination){
            return {
                origin: origin,
                destination: destination,
                travelMode: google.maps.TravelMode.DRIVING
            };
        }

        /**
         * Search in all becomes from Google steps a first one, that is in middle of dimensions (abs of location minus
         * marker's clicked point is smallest as half of dimension for latitude and for longitude). If found this one 
         * - updates marker data and return true.
         * 
         * @param way
         * @param marker
         * @param lat
         * @param lng
         * @param dimension
         * @returns {boolean}
         */
        function getCalibration(way, marker, lat, lng, dimension){
            var wayStageEndpoint;
            for(var i=0; i<way.steps.length; i++){
                wayStageEndpoint = way.steps[i].end_location;
                if(
                        Math.abs(wayStageEndpoint.lat()-lat) < (dimension/2)
                        && Math.abs(wayStageEndpoint.lng()-lng) < (dimension/2)
                ){
                    // If found - update data and return true.
                    marker.setPosition(wayStageEndpoint);
                    marker.infowindow.setContent(infowindowContent(marker));
                    return true;
                }
            }
        }

    </script>

</head>
<body onload="initialize();">
<div id="test"></div>
<div id="map_canvas" style="width:100%; height:100%"></div>
<div id="menus"></div>

</body>
</html>