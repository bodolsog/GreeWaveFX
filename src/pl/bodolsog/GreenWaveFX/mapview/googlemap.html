<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        html { height: 100% }
        body { height: 100%; margin: 0px; padding: 0px }
        #map_canvas { height: 100%; background-color: #666970; }
    </style>
    <script type="text/javascript">
        /*
        * Add to head script file from Google API with Google API key from config.
        */
        var head = document.getElementsByTagName('head')[0];
        var key = properties.getGoogleAPIKey();

        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = 'http://maps.google.com/maps/api/js?key=' + key + '&sensor=false';
        head.appendChild(script);
    </script>
    <script type="text/javascript">
        function initialize() {
            var bounds = new google.maps.LatLngBounds;
            var markersMap = {};

/*            var origin1 = {lat: 52.03, lng: 23.14};
            var origin2 = {lat: 52.05, lng: 23.24};
            var destinationA = {lat: 53.03, lng: 23.84};
            var destinationB = {lat: 53.15, lng: 23.14};*/

            var latlng = new google.maps.LatLng(52.03, 23.14);
            var myOptions = {
                zoom: 15,
                center: latlng,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                mapTypeControl: false,
                navigationControl: false,
                streetViewControl: false,
                backgroundColor: "#666970",
                zoomControl: false,
                scaleControl: true
            };

            document.map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);
            document.geocoder = new google.maps.Geocoder();
            markersId = 0;

            var crossRoadsNames = [];
            var crossRoadsNamesCount = [];

            google.maps.event.addListener(document.map, 'click', function (event) {

                // Create marker
                var marker = new google.maps.Marker({
                    position: event.latLng,
                    draggable: true,
                    map: document.map
                });
                markersId++;
                var markerName = "#"+markersId;
                // Add marker to lists.
                markerList.addMarker(markerName, marker.getPosition().lat(), marker.getPosition().lng());
                markersMap[markerName] = marker;

                getCrossName(markerName, event.latLng.lat(), event.latLng.lng());

                /*
                var infowindow = new google.maps.InfoWindow({
                    content: marker.getCursor()
                });
                marker.addListener('click', function () {
                    infowindow.setOptions({content: marker.getPosition().toString()});
                    infowindow.open(marker.get('map'), marker);
                });
                marker.addListener('drag', function () {
                    infowindow.setOptions({content: marker.getPosition().lat().toString()});
                });
                */

                //var JXmarker = markers;
                //JXmarker.setLatLng(marker.getPosition().lat(), marker.getPosition().lng());
                //document.getElementById('output').innerHTML = markersArray[markersArray.length-1][1].getLatLng();
                //document.getElementById('output').innerHTML = mm.test1();
                //document.getElementById('output').innerHTML = "xxxxxx";
            });


            // Get cross streets names from map.
            function getCrossName(id, lat, lng){
                // Get table witch square's latLng points and search two names by geolocation.
                latLngSquare = getLatLngSquare(lat, lng);
                // Store road names.
                crossRoadsNames[id] = [];
                // Count latLng to check.
                crossRoadsNamesCount[id] = latLngSquare.length;

                wait = false;

                while(latLngSquare.length > 0){
                    // First latLng from array.
                    current = latLngSquare.shift();

                    // Asynchronic reverse geocoding.
                    document.geocoder.geocode({'location': current}, function(results, status) {
                        if(status === google.maps.GeocoderStatus.OVER_QUERY_LIMIT){
                            // When is over free API quota limit: add this latLng back to array as first element and
                            // set wait variable for true (that give 1 sec wait before send next query).
                            latLngSquare.unshift(current);
                            wait = true;
                        } else if(status === google.maps.GeocoderStatus.OK) {
                            if (results[0]) {
                                // When status is ok, become results and road name is not in array crossRoadsNames for
                                // this id - add new road name to this array.
                                if (crossRoadsNames[id].indexOf(results[0].address_components[1].short_name) == -1) {
                                    crossRoadsNames[id].push(results[0].address_components[1].short_name);
                                }
                                // Also decrement (status: ok, become results) crossRoadsNamesCount and, if after
                                // decrementation is equal to 0, send name to marker.
                                crossRoadsNamesCount[id] -= 1;
                                if(crossRoadsNamesCount[id] == 0){
                                    markerList.setName(id, crossRoadsNames[id].join("/"));
                                }
                            }
                        }
                    });
                    if(wait){
                        // If wait is true (setted by status: over_query_limit) - pause script for one second and set
                        // wait variable to false.
                        setTimeout(function(){ wait = false }, 1000);
                    }
                }
            }

            // Return array of lat-lng maps in square range around point.
            function getLatLngSquare(lat, lng){
                mod = 0.00015;
                return [
                    {lat: lat+mod, lng: lng},
                    {lat: lat,     lng: lng-mod},
                    {lat: lat-mod, lng: lng},
                    {lat: lat,     lng: lng+mod}
                ];
            }
        }
    </script>

</head>
<body onload="initialize();">
<div id="map_canvas" style="width:100%; height:100%"></div>

</body>
</html>
